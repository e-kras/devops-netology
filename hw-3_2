1. 

type -t cd
builtin #команда встроенна в оболочку

В оболочке cdиспользуется для «перехода в другой каталог» или, более формально, для изменения текущего рабочего каталога (CWD). Это невозможно реализовать как внешнюю команду:

Текущий рабочий каталог - это каталог, который используется для интерпретации относительных путей для получения полного пути, который можно использовать для доступа к файлам. Относительные пути используются во многих местах, и интерпретация в одном процессе не должна влиять на другой процесс.
По этой причине каждый процесс имеет свой текущий рабочий каталог.

Если бы это была внешняя команда, исполняемый файл в пути, выполняющий этот исполняемый файл, создал бы процесс со своим собственным рабочим каталогом, не влияя на тот из текущей оболочки. Даже если внешняя команда изменит свой каталог, это изменение исчезнет при выходе из внешнего процесса.
 
Поэтому нет смысла запускать внешнюю команду для задачи cd. Команде cd необходимо применить изменения к текущему процессу оболочки.

Для этого это «встроенная команда» оболочки.

Встроенные команды - это команды, которые ведут себя подобно внешним командам, но реализованы в оболочке (поэтому они cdне являются частью coreutils). Это позволяет команде изменить состояние самой оболочки, в этом случае вызвать chdir()

2.

-c, --count
              Suppress normal output; instead print a count of matching lines for each input file.  With the -v, --invert-match option (see below), count non-matching lines.
              
grep <some_string> <some_file> -c
grep <some_string> <some_file> --count

3.

ps -p 1
PID TTY          TIME CMD
  1 ?        00:00:03 systemd

  
4.

ls >/dev/pts/2

5.

cat < README.md | tee README_3_2.md

6. 

ls -la ../devops-netology > /dev/tty2

Для того чтобы увидеть результат необходимо переключиться на вторую консоль - Ctrl+Alt+F2

7.

bash 5>&1 #создаст новый файловый дискриптор 5 и перенаправит его на stdout

echo netology > /proc/$$/fd/5 #выведется netology в текущем терминале, из-за перенаправления вывода в дискриптор 5, а учитывая ранее выполненную команду (bash 5>&1) перенаправит на stdout
netology

8.

ls /no-dir /home  5>&1 1>&2 2>&5 | grep cannot
/home:
vagrant
ls: cannot access '/no-dir': No such file or directory


#Для того чтобы поменять местами stdout и stderr необходимо
#5>&1 новый дескриптор перенаправить в stdout
#1>&2 stdout перенаправить в stderr
#2>&5 stderr перенаправить в новый дескриптор



9.

cat /proc/$$/environ #Команда выводит переменные окружения для текущего процесса bash, заданные на этапе запуска этого процесса. Аналогичный вывод можно сделать командой env

SHELL=/bin/bashSESSION_MANAGER=local/ZB-07:@/tmp/.ICE-unix/6197,unix/ZB-07:/tmp/.ICE-unix/6197WINDOWID=0QT_ACCESSIBILITY=1COLORTERM=truecolorXDG_CONFIG_DIRS=/etc/xdg/xdg-plasma:/etc/xdg:/usr/share/kubuntu-default-settings/kf5-settingsXDG_SESSION_PATH=/org/freedesktop/DisplayManager/Session1LANGUAGE=SSH_AUTH_SOCK=/tmp/ssh-roS2BGt81e4E/agent.6090SHELL_SESSION_ID=1265a9f39830414eab44fc5844764f81DESKTOP_SESSION=plasmaSSH_AGENT_PID=6134XDG_SEAT=seat0P..............

10.

# /proc/<PID>/cmdline - полный путь до исполняемого файла процесса [PID]
# /proc/<PID>/exe - содержит ссылку до файла запущенного для процесса [PID]


11.

sse4_2 


12.

#По умолчанию при выполнении команды по ssh не выделяется псевдо-терминал, надо принудиельно выделить tty ключом -t
ssh -t localhost 'tty'

13.

reptytr PID 

14.

Так происходит потому, что мы запускаем с правами суперпользователя команду echo и она честно выводит строку string в стандартный вывод bash с правами суперпользователя. Но bash запущен от обычного пользователя, и когда интерпретатор bash пытается записать полученную строчку в файл домашней директории суперпользователя /root, естественно, что мы получаем ошибку. Поэтому для решения задачи можно использовать команду tee, которая читает стандартный ввод, переданный ей через pipe, и записывает его в стандартный вывод или файл уже с повышенными привилегиями sudo.



